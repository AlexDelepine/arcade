<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Overview </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Overview ">
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="">
      <meta name="docfx:tocrel" content="">
      
      
      
      
      
  </head>

  <script type="module">
    import options from './../../../public/main.js'
    import { init } from './../../../public/docfx.min.js'
    init(options)
  </script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="overview">Overview</h1>

<p>The requirement for Platform/OS onboarding is that it should be relatively painless to add/update/delete Queues/Scalesets and doable by all customers.</p>
<h1 id="requirements">Requirements</h1>
<ul>
<li>All Exisiting queue/scaleset combos are described in one or more yaml files in a VSTS/Github Repo which looks something like this.</li>
</ul>
<pre><code>- &amp;Windows10
  Name: Windows.10
  AzureImage:
    Name: Windows
    Version: 10
  Artifacts:
    - vs_15_08
    - helix_runtime
  MaximumScale: 50
  Owner: abc@
  
- &lt;&lt;: *Windows10
  Name: Windows.10.Open
  Public: true
  MaximumScale: 20
  Owner: abc@

- Name: Windows.7.Amd64
  Public: true
  MaximumScale: 20
  location: westus
  tags: {
        &quot;QueueId&quot;: &quot;Windows.7.Amd64&quot;,
        &quot;ResourceGroupName&quot;: &quot;Windows.7.Amd64.WestUS&quot;,
        &quot;WorkspacePath&quot;: &quot;D:\\\\j&quot;,
        &quot;IsAvailable&quot;: &quot;true&quot;,
        &quot;IsInternalOnly&quot;: &quot;true&quot;,
        &quot;UserList&quot;: &quot;all&quot;,
        &quot;OperatingSystemGroup&quot;: &quot;windows&quot;
      }
  scaling rule: &lt;JSON&gt;
  Owner: abc@
  
- Name: Windows.7.Client
  BaseImage: http://dotnet-eng-images.storage.azure.net/base-images/Windows.7.Client/15.6.750.vhd
  Artifacts:
    - vs_15_08
    - helix_runtime
  MaximumScale: 3000
  Owner: abc@
 
- Name: OSX.1012
  Unmanaged: true
  Owner: abc@
  
- Name: TOF.External
  Unmonitored: true
  Owner: abc@
</code></pre>
<ul>
<li>User makes a PR to the repo to add/edit/delete scalesets in one of the yaml files.</li>
<li>Validation Service in the Repo runs sanity checks on like “Does that image exist” and “Are those artifacts known artifacts”, if possible.</li>
<li>If Validation succeeds, send a PR to Image Creation Factory with specific parameters (TBD) to create Image /Artifcacts .</li>
<li>Wait for the image to be created, Image Factory notifies via a webhook with a status (&quot;image complete&quot;/&quot;failed to create an image&quot; etc.)</li>
<li>If the image is created, validate that the image works by creating a scaleset and deploying to INT/staging with one machine and test with a sample job. If artifacts are requested, quick validation per artifact to make sure the artifact is operating as expected (e.g. if someone wanted VS, make sure a “msbuild test.proj” does the right stuff, if helix is request, make sure it reads a queued item and processes a job)</li>
<li>If anything failed, mark the PR as failed</li>
<li>Maintain an image mapping yaml, which contains a mapping against commit# and the Image/Artifact created by the Image Creation Factory.</li>
<li>When the User-initated PR or PR to update image mapping yaml merges, initiate CI build/release that
<ul>
<li>Creates any required queue</li>
<li>Transforms every defined scaleset/queue combo into an Azure ARM template and pushes all those, which will update any existing scale set, and create new ones as necessary. This might involve fetching some temporary secrets to initialize things</li>
<li>Delete any scale/set queue that is defined but not in this repository anymore (so we can decommission things)</li>
</ul>
</li>
<li>To handle updating existing scale sets (some VMs running “newer” images than others), we need to augment the VM cleanup tool to detect when there are “older” VM’s in the scale set that contains newer ones and mark them as “unhealthy” so the get deleted, and newer images take their place</li>
<li>Cleanup service runs periodically every n days to clean up outdated VMs/scalesets, update Image Mapping yaml accordingly.</li>
<li>Add Helix as an Artifact to ImageFactory</li>
</ul>
<h1 id="dev-work-flow">Dev Work Flow</h1>
<p><img src="./Images/DevWorkFlow.JPG?raw=true" alt=""></p>
<!-- Begin Generated Content: Doc Feedback -->
<p><sub>Was this helpful? <a href="https://helix.dot.net/f/p/5?p=Documentation%5CProject-Docs%5COS%20Onboarding%5CRequirements.md"><img src="https://helix.dot.net/f/ip/5?p=Documentation%5CProject-Docs%5COS%20Onboarding%5CRequirements.md" alt="Yes"></a> <a href="https://helix.dot.net/f/n/5?p=Documentation%5CProject-Docs%5COS%20Onboarding%5CRequirements.md"><img src="https://helix.dot.net/f/in" alt="No"></a></sub></p>
<!-- End Generated Content-->
</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>
        
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>